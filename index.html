<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SchemaScript</title>
<style>
  :root{
    --rosa-chiaro:#ffe6f0;
    --rosa-medio:#fff0f5;
    --rosa-accento:#d63384;
    --rosa-bottone:#e83e8c;
    --rosa-bottone-hover:#c2185b;
  }
  body{
    font-family:"Segoe UI","Helvetica Neue",sans-serif;
    background:var(--rosa-chiaro);
    margin:0;padding:1rem;display:flex;flex-direction:column;align-items:center;min-height:100vh;box-sizing:border-box;
  }
  h1{ color:var(--rosa-accento); font-size:2rem; font-weight:700; margin:0 0 1.2rem; text-align:center; }
  textarea{
    width:100%; max-width:900px; height:160px; font-family:monospace; font-size:1rem; padding:12px; border-radius:10px;
    border:1px solid var(--rosa-accento); background:var(--rosa-medio); color:#333; box-sizing:border-box; resize:vertical;
  }
  #controls{ position:sticky; top:0; background:var(--rosa-chiaro); padding:0.6rem; display:flex; flex-wrap:wrap; gap:0.6rem;
    justify-content:center; width:100%; max-width:900px; z-index:10; }
  button{ padding:10px 16px; border:none; border-radius:10px; background:var(--rosa-bottone); color:#fff; font-weight:700; cursor:pointer;
    transition:background .25s, transform .08s; }
  button:hover{ background:var(--rosa-bottone-hover); } button:active{ transform:scale(.98); }
  #schema{ margin-top:20px; background:var(--rosa-medio); border-radius:16px; padding:16px; box-shadow:0 4px 14px rgba(0,0,0,.1);
    width:100%; max-width:900px; box-sizing:border-box; overflow-x:hidden; }
  .title{ text-align:center; font-size:1.8em; font-weight:700; color:var(--rosa-accento); margin-bottom:1em; word-break:break-word; }
  .section{ border-left:4px solid var(--rosa-accento); padding-left:12px; margin-bottom:1em; background:var(--rosa-medio);
    border-radius:12px; padding:10px 15px; word-break:break-word; }
  .header-name{ font-weight:700; font-size:1.2em; color:var(--rosa-accento); margin-bottom:.5em; }
  .paragraph{ background:#fff; padding:8px 10px; border-radius:8px; border:1px solid #ffc0d6; margin-left:15px; margin-bottom:.6em;
    box-shadow:1px 1px 3px rgba(214,51,132,.15); white-space:pre-wrap; line-height:1.4em; }
  .section img{ max-width:100%; height:auto; margin:8px 0 8px 15px; border-radius:8px; border:1px solid #ffc0d6; background:#fff0f5; display:block; }
  #imagePreview{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin-top:10px; }
  #imagePreview div{ position:relative; }
  #imagePreview img{ max-width:80px; border-radius:8px; border:1px solid #ffc0d6; display:block; }
  #imagePreview span{ position:absolute; top:-6px; left:-6px; background:var(--rosa-accento); color:white; font-size:12px; border-radius:50%; padding:2px 6px; }
  ol{ counter-reset:item; margin:10px 0; padding:0; list-style:none; }
  ol li{ counter-increment:item; background:#fff; border:1px solid #ffc0d6; border-radius:8px; padding:8px 12px; margin-bottom:6px;
    box-shadow:1px 1px 3px rgba(214,51,132,.15); line-height:1.4em; }
  ol li::before{ content:counter(item) ". "; font-weight:700; color:#d63384; margin-right:6px; }
  @media (max-width:600px){
    body{ padding:.8rem; } h1{ font-size:1.6rem; margin-bottom:1rem; }
    textarea{ font-size:.9rem; height:140px; } button{ flex:1 1 45%; font-size:.9rem; padding:9px 12px; }
    .section{ padding:8px 10px; } .paragraph{ margin-left:10px; font-size:.9rem; } ol li{ font-size:.9rem; padding:6px 8px; }
    #imagePreview img{ max-width:65px; }
  }
</style>
</head>
<body>
  <h1>SchemaScript</h1>

  <textarea id="code" placeholder="Scrivi qui il tuo SchemaScript..."></textarea>

  <div id="controls">
    <input type="file" id="imageUpload" accept="image/*" multiple>
    <input type="text" id="fileName" placeholder="Nome file..." />
    <button id="runButton">Genera schema</button>
    <button id="downloadButton">Scarica PNG</button>
  </div>

  <div id="imagePreview"></div>
  <div id="schema"></div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
  // Parser robusto: RAMO CON ... usa l'ultima sezione/nodo creato se non Ã¨ specificato il target.
  const codeEl = document.getElementById('code');
  const runBtn = document.getElementById('runButton');
  const downloadBtn = document.getElementById('downloadButton');
  const imgUpload = document.getElementById('imageUpload');
  const imgPreview = document.getElementById('imagePreview');
  const schema = document.getElementById('schema');
  const fileNameInput = document.getElementById('fileName');

  // immagini memorizzate per nome e array per indici
  const imagesByName = {};
  const imagesArray = [];

  imgUpload.addEventListener('change', e=>{
    imgPreview.innerHTML = '';
    imagesByNameClear();
    let idx = 1;
    for (const f of imgUpload.files) {
      const reader = new FileReader();
      reader.onload = ev=>{
        imagesByName[f.name] = ev.target.result;
        imagesArray.push(ev.target.result);
        const div = document.createElement('div');
        const img = document.createElement('img');
        img.src = ev.target.result;
        const sp = document.createElement('span');
        sp.textContent = idx++;
        div.appendChild(img); div.appendChild(sp);
        imgPreview.appendChild(div);
      };
      reader.readAsDataURL(f);
    }
  });

  function imagesByNameClear(){
    for (const k in imagesByName) delete imagesByName[k];
    imagesArray.length = 0;
  }

  // helpers token detection
  function isTokenLine(trimmed) {
    if (!trimmed) return false;
    const t = ['TITOLO','SEZIONE','RAMO','PARAGRAFO','LISTA','IMMAGINE'];
    const up = trimmed.toUpperCase();
    for (const tok of t) if (up.startsWith(tok)) return true;
    return false;
  }

  runBtn.addEventListener('click', ()=> {
    const text = codeEl.value.replace(/\r/g,'');
    renderFromText(text);
  });

  function renderFromText(text) {
    schema.innerHTML = '';
    if (!text) return;
    const lines = text.split('\n');
    // state
    let lastCreatedNode = null;   // DOM element of last created section/subsection
    const nodesByName = {};       // mapping normalizzato -> DOM element (per target lookup)
    let globalTitleAdded = false;

    // normalize key
    function normKey(s){
      return (s||'').normalize?.("NFD").replace(/[\u0300-\u036f]/g,'').replace(/[^\w\s]/g,'').toLowerCase().trim();
    }

    // create section element and register
    function createSectionElement(name, parentEl) {
      const sec = document.createElement('div');
      sec.className = 'section';
      if (name && name.trim() !== '') {
        const header = document.createElement('div');
        header.className = 'header-name';
        header.textContent = name;
        sec.appendChild(header);
      }
      if (parentEl && parentEl.classList && parentEl.classList.contains('section')) {
        parentEl.appendChild(sec);
      } else {
        schema.appendChild(sec);
      }
      if (name && name.trim() !== '') {
        nodesByName[normKey(name)] = sec;
        nodesByName[name] = sec;
      }
      lastCreatedNode = sec;
      return sec;
    }

    // append paragraph
    function appendParagraph(parentEl, text) {
      const p = document.createElement('div');
      p.className = 'paragraph';
      p.textContent = text;
      (parentEl || schema).appendChild(p);
      lastCreatedNode = parentEl || lastCreatedNode;
      return p;
    }

    // append list
    function appendList(parentEl, items) {
      const ol = document.createElement('ol');
      ol.style.marginLeft = '20px';
      items.forEach(it=>{
        const li = document.createElement('li');
        li.textContent = it;
        ol.appendChild(li);
      });
      (parentEl || schema).appendChild(ol);
      lastCreatedNode = parentEl || lastCreatedNode;
      return ol;
    }

    // append image
    function appendImage(parentEl, src) {
      if (!src) return null;
      const img = document.createElement('img');
      img.src = src;
      (parentEl || schema).appendChild(img);
      lastCreatedNode = parentEl || lastCreatedNode;
      return img;
    }

    // iterate lines
    for (let i = 0; i < lines.length; i++) {
      const raw = lines[i].replace(/\t/g,'    '); // keep but ignore indentation semantically
      const line = raw.trim();
      if (!line) continue;

      const up = line.toUpperCase();

      // TITOLO
      if (up.startsWith('TITOLO')) {
        const rest = line.slice('TITOLO'.length).trim();
        const titleDiv = document.createElement('div');
        titleDiv.className = 'title';
        titleDiv.textContent = rest;
        schema.appendChild(titleDiv);
        globalTitleAdded = true;
        continue;
      }

      // SEZIONE
      if (up.startsWith('SEZIONE')) {
        let name = line.slice('SEZIONE'.length).trim();
        // if empty, and next non-empty non-token line exists, use it as name (allows multi-line)
        if (!name) {
          // lookahead
          let j = i+1;
          while (j < lines.length && !lines[j].trim()) j++;
          if (j < lines.length && !isTokenLine(lines[j].trim())) {
            name = lines[j].trim();
            i = j; // consume that line
          }
        }
        createSectionElement(name || '');
        continue;
      }

      // RAMO (branch)
      if (up.startsWith('RAMO')) {
        // take everything after RAMO
        let afterRamo = line.slice(4).trim(); // may be empty or "CON ..." or "<target> CON ..."
        // find " CON " (word)
        const conMatch = afterRamo.match(/\bCON\b/i);
        if (!conMatch) {
          // If no CON, treat remainder as a paragraph appended to lastCreatedNode
          if (afterRamo) appendParagraph(lastCreatedNode, afterRamo);
          continue;
        }
        const conIndex = conMatch.index;
        let targetRaw = afterRamo.slice(0, conIndex).trim(); // may be '' => use lastCreatedNode
        let afterCon = afterRamo.slice(conIndex + 3).trim(); // e.g. "PARAGRAFO:" or "SEZIONE Name" etc.

        // if targetRaw empty, use lastCreatedNode; else try lookup in nodesByName, otherwise create a section with that name at root
        let parentEl = null;
        if (targetRaw) {
          parentEl = nodesByName[normKey(targetRaw)] || nodesByName[targetRaw];
          if (!parentEl) {
            // create a top-level section for that target name so branches can attach to it
            parentEl = createSectionElement(targetRaw || '');
          }
        } else {
          // no explicit target: use lastCreatedNode or the last top-level section
          parentEl = lastCreatedNode || null;
          if (!parentEl) {
            // fallback: create an anonymous top-level section
            parentEl = createSectionElement('');
          }
        }

        // determine action type: PARAGRAFO, SEZIONE, LISTA, IMMAGINE
        const upAfter = afterCon.toUpperCase();
        if (upAfter.startsWith('PARAGRAFO')) {
          // collect following lines until next token line or EOF
          const collected = [];
          // if there is inline text after PARAGRAFO: use it first (rare)
          let inline = afterCon.slice('PARAGRAFO'.length);
          if (inline.startsWith(':')) inline = inline.slice(1);
          inline = inline.trim();
          if (inline) collected.push(inline);

          let j = i + 1;
          while (j < lines.length) {
            const nxt = lines[j].trim();
            if (!nxt) { collected.push(''); j++; continue; }
            if (isTokenLine(nxt)) break;
            collected.push(nxt);
            j++;
          }
          i = Math.max(i, j-1);
          if (collected.length > 0) appendParagraph(parentEl, collected.join('\n').trim());
          continue;
        }

        if (upAfter.startsWith('SEZIONE')) {
          // create a new subsection under parentEl with specified name
          let name = afterCon.slice('SEZIONE'.length).trim();
          if (!name) {
            // if next non-token line contains name, take it
            let j = i+1;
            while (j < lines.length && !lines[j].trim()) j++;
            if (j < lines.length && !isTokenLine(lines[j].trim())) {
              name = lines[j].trim();
              i = j; // consume that line
            }
          }
          const newSec = createSectionElement(name || '', parentEl);
          // register the newly created subsection by name
          if (name) nodesByName[normKey(name)] = newSec;
          // set lastCreatedNode to the new section so subsequent "RAMO CON ..." will branch from it
          lastCreatedNode = newSec;
          continue;
        }

        if (upAfter.startsWith('LISTA')) {
          // collect list items from following lines until token encountered
          const items = [];
          // inline after LISTA:
          let inline = afterCon.slice('LISTA'.length);
          if (inline.startsWith(':')) inline = inline.slice(1);
          inline = inline.trim();
          if (inline) items.push(inline);
          let j = i + 1;
          while (j < lines.length) {
            const nxt = lines[j].trim();
            if (!nxt) { j++; continue; }
            if (isTokenLine(nxt)) break;
            items.push(nxt);
            j++;
          }
          i = Math.max(i, j-1);
          if (items.length > 0) appendList(parentEl, items);
          continue;
        }

        if (upAfter.startsWith('IMMAGINE')) {
          // after IMMAGINE may follow ": name" or number
          let payload = afterCon.slice('IMMAGINE'.length).trim();
          if (payload.startsWith(':')) payload = payload.slice(1).trim();
          // try name lookup or numeric index
          let src = null;
          if (payload) {
            if (imagesByName[payload]) src = imagesByName[payload];
            else {
              const n = parseInt(payload);
              if (!Number.isNaN(n) && imagesArray[n-1]) src = imagesArray[n-1];
            }
          } else {
            // if no payload, try next non-token line as name/index
            let j = i + 1;
            while (j < lines.length && !lines[j].trim()) j++;
            if (j < lines.length && !isTokenLine(lines[j].trim())) {
              const candidate = lines[j].trim();
              if (imagesByName[candidate]) src = imagesByName[candidate];
              else {
                const n = parseInt(candidate);
                if (!Number.isNaN(n) && imagesArray[n-1]) src = imagesArray[n-1];
              }
              i = j;
            }
          }
          if (src) appendImage(parentEl, src);
          continue;
        }

        // default: if afterCon has something not matched, append it as paragraph text in parentheses
        if (afterCon) appendParagraph(parentEl, '(' + afterCon + ')');
        continue;
      } // end RAMO

      // fallback: if we reach here, treat the line as paragraph under lastCreatedNode
      appendParagraph(lastCreatedNode, line);
    } // end for lines
  } // end renderFromText

  // download as PNG
  downloadBtn.addEventListener('click', ()=>{
    html2canvas(schema).then(canvas=>{
      const a = document.createElement('a');
      a.href = canvas.toDataURL('image/png');
      a.download = (fileNameInput.value.trim() || 'schema') + '.png';
      a.click();
    });
  });

  </script>
</body>
</html>
