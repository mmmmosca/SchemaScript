<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8">
<title>SchemaScript Visual Playground</title>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<style>
  body {
    font-family: "Segoe UI", sans-serif;
    background: #ffeef4;
    margin: 2rem;
  }
  textarea {
    width: 100%;
    height: 150px;
    font-family: monospace;
    padding: 10px;
    border: 2px solid #ffbad2;
    border-radius: 8px;
    background: #fff0f6;
    color: #333;
  }
  input[type="text"] {
    padding: 5px 8px;
    border-radius: 6px;
    border: 1px solid #ffbad2;
    width: 200px;
    margin-right: 10px;
  }
  button {
    margin-top: 10px;
    margin-right: 10px;
    padding: 8px 12px;
    border: none;
    border-radius: 8px;
    background: #ff85c0;
    color: white;
    cursor: pointer;
  }
  button:hover { background: #ff4fa3; }
  #schema {
    margin-top: 20px;
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(255, 150, 200, 0.3);
    overflow-x: auto;
  }

  /* blocchi */
  .title {
    text-align: center;
    font-size: 1.8em;
    font-weight: bold;
    color: #ff4fa3;
    margin-bottom: 1em;
  }
  .section {
    border-left: 4px solid #ff85c0;
    padding-left: 12px;
    margin-bottom: 1em;
  }
  .section > .header-name {
    font-weight: bold;
    font-size: 1.2em;
    color: #d63384;
    margin-bottom: 0.5em;
  }
  .paragraph {
    background: #ffe0f0;
    padding: 8px 12px;
    border-radius: 8px;
    margin-left: 20px;
    margin-bottom: 0.5em;
    white-space: pre-wrap; /* mantiene a capo e spazi */
  }
</style>
</head>
<body>

<h1>SchemaScript</h1>
<textarea id="code"></textarea>
<br>
<button onclick="generateSchema()">Genera Schema</button>
<br><br>
<label for="filename">Nome file:</label>
<input type="text" id="filename" placeholder="schema.png" value="schema.png">
<button onclick="downloadPNG()">Scarica PNG</button>

<div id="schema"></div>

<script>
function parseSchemaScript(code) {
  const lines = code.split(/\r?\n/).map(l => l.replace(/\r$/, ""));
  const tokens = ["TITOLO", "SEZIONE", "RAMO", "CON", "PARAGRAFO"];

  let i = 0;
  const result = { title: "", sections: [] };
  const nodesByName = {};

  while (i < lines.length) {
    const raw = lines[i];
    const line = raw.trim();
    if (!line) { i++; continue; }

    // --- TITOLO ---
    if (line.startsWith(tokens[0])) {
      result.title = line.slice(tokens[0].length).trim();
    }

    // --- SEZIONE ---
    else if (line.startsWith(tokens[1])) {
      const val = line.slice(tokens[1].length).trim();
      const node = { name: val, children: [] };
      result.sections.push(node);
      nodesByName[val] = node;
    }

    // --- RAMO <target> CON X ---
    else if (line.startsWith(tokens[2])) {
      const parts = line.split(/\s+/);
      if (parts.length >= 4 && parts[2] === tokens[3]) {
        const targetName = parts[1];
        const afterWith = parts.slice(3).join(" ").trim();

        const parentNode = nodesByName[targetName] || (() => {
          const n = { name: targetName, children: [] };
          result.sections.push(n);
          nodesByName[targetName] = n;
          return n;
        })();

        // --- CON PARAGRAFO multilinea ---
        if (afterWith.startsWith(tokens[4])) {
          let j = i + 1;
          let paragraphLines = [];
          while (j < lines.length) {
            const l = lines[j].trim();
            if (!l || tokens.some(t => l.startsWith(t))) break;
            paragraphLines.push(lines[j]);
            j++;
          }
          if (paragraphLines.length) {
            parentNode.children.push({ type: "paragraph", text: paragraphLines.join("\n") });
            i = j - 1;
          }
        }

        // --- CON SEZIONE ---
        else if (afterWith.startsWith(tokens[1])) {
          let headerVal = afterWith.slice(tokens[1].length).trim();
          if (!headerVal && i + 1 < lines.length) {
            headerVal = lines[i + 1].trim();
            i++;
          }
          if (headerVal) {
            const newNode = { name: headerVal, children: [] };
            parentNode.children.push(newNode);
            nodesByName[headerVal] = newNode;
          }
        }

        else if (afterWith) {
          parentNode.children.push({ type: "paragraph", text: "(" + afterWith + ")" });
        }
      }
    }

    // --- fallback ---
    else {
      const lastSection = result.sections[result.sections.length - 1];
      if (lastSection) {
        lastSection.children.push({ type: "paragraph", text: line });
      }
    }

    i++;
  }

  return result;
}

function renderSection(section, container) {
  const div = document.createElement("div");
  div.className = "section";

  const header = document.createElement("div");
  header.className = "header-name";
  header.textContent = section.name;
  div.appendChild(header);

  section.children.forEach(child => {
    if (child.type === "paragraph") {
      const p = document.createElement("div");
      p.className = "paragraph";
      p.textContent = child.text;
      div.appendChild(p);
    } else if (child.name) {
      renderSection(child, div);
    }
  });

  container.appendChild(div);
}

function generateSchema() {
  const code = document.getElementById("code").value;
  const parsed = parseSchemaScript(code);
  const container = document.getElementById("schema");
  container.innerHTML = "";

  if (parsed.title) {
    const titleDiv = document.createElement("div");
    titleDiv.className = "title";
    titleDiv.textContent = parsed.title;
    container.appendChild(titleDiv);
  }

  parsed.sections.forEach(sec => renderSection(sec, container));
}

function downloadPNG() {
  const container = document.getElementById("schema");
  const filenameInput = document.getElementById("filename");
  const filename = filenameInput.value.trim() || "schema.png";

  html2canvas(container).then(canvas => {
    const link = document.createElement("a");
    link.download = filename.endsWith(".png") ? filename : filename + ".png";
    link.href = canvas.toDataURL();
    link.click();
  });
}
</script>

</body>
</html>